#include "hardware.h"
#ifdef ENCODER_MAGNETIC
#include <stdlib.h>
#include <wirish/wirish.h>
#include <terminal.h>
#include <watchdog.h>
#include "motor.h"
#include "encoder.h"
#include "servo.h"
#include "security.h"

HardwareSPI encoder(ENCODER_SPI);

// Counter value
static uint32_t encoder_cnt = 0;
static uint16_t encoder_magnitude = 0;
static bool encoder_present = true;

int encoder_to_int(){
    if( encoder_cnt >= HALF_MAX_ENCODER_CNT ){
        return (encoder_cnt - MAX_ENCODER_CNT);
    }else{
        return encoder_cnt;
    }
}


bool encoder_is_ok()
{
    return encoder_magnitude > 500;
}

bool encoder_is_present()
{
    return encoder_present;
}




static int encoder_read_state = -1;
static uint16_t encoder_read_result = 0;
static uint16_t encoder_read_magnitude = 0;

// begin of automatic code - generated by integer_calculus.py
#define ENCODER_SPEED_SCALE 16384
#define THETA_OUT_SCALE 16384
#define THETA_0_SCALE 16384
#define FILTER_NUM_SCALE 549755813888
#define ENCODER_CNT_0_SCALE 16384
#define ENCODER_CNT_1_SCALE 16384
#define ENCODER_CNT_2_SCALE 16384
#define ENCODER_CNT_3_SCALE 16384
#define FILTER_DEN_SCALE 268435456
#define THETA_1_SCALE 16384
#define THETA_2_SCALE 16384
#define THETA_3_SCALE 16384
// end of automatic code - generated by integer_calculus.py

#define ENCODER_CNT_SCALE 16384

// begin of automatic code - generated by integer_calculus.py
static int encoder_speed = 0*ENCODER_SPEED_SCALE;
static int theta_out_0 = 0*THETA_OUT_SCALE;
static int theta_0 = 0*THETA_0_SCALE;
static int filter_num = 0*FILTER_NUM_SCALE;
static int encoder_cnt_0 = 0*ENCODER_CNT_0_SCALE;
static int encoder_cnt_1 = 0*ENCODER_CNT_1_SCALE;
static int encoder_cnt_2 = 0*ENCODER_CNT_2_SCALE;
static int encoder_cnt_3 = 0*ENCODER_CNT_3_SCALE;
static int filter_den = 0*FILTER_DEN_SCALE;
static int theta_1 = 0*THETA_1_SCALE;
static int theta_2 = 0*THETA_2_SCALE;
static int theta_3 = 0*THETA_3_SCALE;
// end of automatic code - generated by static integer_calculus.py


static int theta_out_1 = 0*THETA_OUT_SCALE;
static int theta_out_2 = 0*THETA_OUT_SCALE;
static int theta_out_3 = 0*THETA_OUT_SCALE;
static int theta_out_4 = 0*THETA_OUT_SCALE;
static int theta_out_5 = 0*THETA_OUT_SCALE;
static int theta_out_6 = 0*THETA_OUT_SCALE;
static int theta_out_7 = 0*THETA_OUT_SCALE;
static int theta_out_8 = 0*THETA_OUT_SCALE;
static int low_2_speed = 0*ENCODER_SPEED_SCALE;
static int low_3_speed = 0*ENCODER_SPEED_SCALE;
static int low_4_speed = 0*ENCODER_SPEED_SCALE;
static int low_8_speed = 0*ENCODER_SPEED_SCALE;
                    
static int theta_base = 0*THETA_0_SCALE;
static int past_theta = 0*THETA_OUT_SCALE;

uint16_t magnetic_value = 0;
static int32_t encoder_deltas = 0;

inline int32_t encoder_compute_delta(uint16_t a, uint16_t b)
{
    int32_t delta = b - a;

    if (delta > 0x1fff) {
        delta -= 0x4000;
    }
    if (delta < -0x1fff) {
        delta += 0x4000;
    }

    return delta;
}

static bool encoder_flag = false;


static float theta_3_d = 0.0;
static float theta_2_d = 0.0;
static float theta_1_d = 0.0;
static float theta_0_d = 0.0;

static float encoder_cnt_0_d = 0.0;
static float encoder_cnt_1_d = 0.0;
static float encoder_cnt_2_d = 0.0;
static float encoder_cnt_3_d = 0.0;

float num_d = 0.0;
float den_d = 0.0;


extern "C"
{
void __irq_spi2()
{
    if (spi_is_tx_empty(SPI2)) {
        switch (encoder_read_state) {
            case 0: {
                encoder_read_result = (SPI2->regs->DR << 8);
                SPI2->regs->DR = 0xfe;
                encoder_read_state++;
                break;
            }
            case 1: {
                encoder_read_result |= SPI2->regs->DR;
                GPIOB->regs->BSRR = (1U << 12);
                delay_us(1);
                GPIOB->regs->BSRR = (1U << 12) << 16;
                delay_us(1);
                SPI2->regs->DR = 0xff;
                encoder_read_state++;
                break;
            }
            case 2: {
                encoder_read_magnitude = (SPI2->regs->DR << 8);
                SPI2->regs->DR = 0xff;
                encoder_read_state++;
                break;
            }
            case 3: {
                encoder_read_magnitude |= SPI2->regs->DR;
                encoder_magnitude = encoder_read_magnitude & 0x3fff;
                encoder_read_result &= 0x3fff;
                encoder_read_state = -1;
                GPIOB->regs->BSRR = (1U << 12);
                spi_irq_disable(SPI2, SPI_TXE_INTERRUPT);

                // TODO ! Check thet errors !

                // Doit-on mettre ce calcul ici ou dans encoder_tick pour viter 
                // toutes surcharge de calcul ?
                encoder_deltas = encoder_compute_delta(magnetic_value, encoder_read_result);
                magnetic_value = (magnetic_value + encoder_deltas + 0x4000)%(0x4000);
                encoder_cnt -= encoder_deltas;


                const float d_0 = 2414.790782274951;

                const float n_0 = 1.0/d_0;
                const float n_1 = 3.0/d_0;
                const float n_2 = 3.0/d_0;
                const float n_3 = 1.0/d_0;

                const float d_1 = +6488.057607935079/d_0;
                const float d_2 = -5845.602032624118/d_0;
                const float d_3 = +1764.3352069639898/d_0;

                encoder_cnt_3_d = encoder_cnt_2_d;
                encoder_cnt_2_d = encoder_cnt_1_d;
                encoder_cnt_1_d = encoder_cnt_0_d;
                encoder_cnt_0_d = encoder_to_int();

                theta_3_d = theta_2_d;
                theta_2_d = theta_1_d;
                theta_1_d = theta_0_d;
                num_d = (
                    n_0 * encoder_cnt_0_d +
                    n_1 * encoder_cnt_1_d +
                    n_2 * encoder_cnt_2_d +
                    n_3 * encoder_cnt_3_d
                );

                den_d = (
                    d_1 * theta_1_d +
                    d_2 * theta_2_d +
                    d_3 * theta_3_d
                );
                theta_0_d = num_d + den_d;


        
#if 0
                // begin of automatic code - generated by integer_calculus.py
                encoder_cnt_3 = (encoder_cnt_2);
                encoder_cnt_2 = (encoder_cnt_1);
                encoder_cnt_1 = (encoder_cnt_0);
                encoder_cnt_0 = (encoder_cnt);
                theta_3 = (theta_2);
                theta_2 = (theta_1);
                theta_1 = (theta_0);
                filter_num = ((((encoder_cnt_1/1)*((2667912)/32))/1 + ((encoder_cnt_0/1)*((889304)/8))/4)/2 + (((encoder_cnt_2/1)*((2667912)/32))/1 + ((encoder_cnt_3/1)*((889304)/8))/4)/2);
                filter_den = (((theta_1/1)*((1442464262)/16384))/2 + (((theta_2/1)*((-1299629648)/16384))/1 + ((theta_3/1)*((1569030755)/16384))/4)/2);
                theta_0 = ((filter_den/1 + filter_num/2048)/16384);
                // end of automatic code - generated by integer_calculus.py
                
                if( theta_0 >= THETA_0_SCALE ){
                    encoder_cnt_3 -= ENCODER_CNT_3_SCALE;
                    encoder_cnt_2 -= ENCODER_CNT_2_SCALE;
                    encoder_cnt_1 -= ENCODER_CNT_1_SCALE;
                    encoder_cnt_0 -= ENCODER_CNT_0_SCALE;
                    encoder_cnt -= ENCODER_CNT_SCALE;
                    theta_3 -= THETA_3_SCALE;
                    theta_2 -= THETA_2_SCALE;
                    theta_1 -= THETA_1_SCALE;
                    theta_0 -= THETA_0_SCALE;
                    theta_base += THETA_0_SCALE;
                }
                if( theta_0 <= -THETA_0_SCALE ){
                    encoder_cnt_3 += ENCODER_CNT_3_SCALE;
                    encoder_cnt_2 += ENCODER_CNT_2_SCALE;
                    encoder_cnt_1 += ENCODER_CNT_1_SCALE;
                    encoder_cnt_0 += ENCODER_CNT_0_SCALE;
                    encoder_cnt += ENCODER_CNT_SCALE;
                    theta_3 += THETA_3_SCALE;
                    theta_2 += THETA_2_SCALE;
                    theta_1 += THETA_1_SCALE;
                    theta_0 += THETA_0_SCALE;
                    theta_base -= THETA_0_SCALE;
                }
#endif
                encoder_flag = false;
                break;
            }
        }
    }
}
}

unsigned int encoder_counter = 0;
#define ENCODER_FREQUENCE 8000
#define SUB_SAMPLE_FREQUENCE 800
#define SUB_SAMPLE_FACTOR 10
static_assert( SUB_SAMPLE_FREQUENCE*SUB_SAMPLE_FACTOR == ENCODER_FREQUENCE, "Shanon version X10");
// TODO Mettre la contrainte de shanon concerant le sous Ã©chantillonage !

// Instruction

static uint16_t encoder_read_value()
{
    if( encoder_flag ){
        security_set_warning(WARNING_ENCODER_LAG);
    }
    encoder_flag = true;
    encoder_counter ++;
    if( encoder_counter >= SUB_SAMPLE_FACTOR ){
        theta_out_8 = theta_out_7;
        theta_out_7 = theta_out_6;
        theta_out_6 = theta_out_5;
        theta_out_5 = theta_out_4;
        theta_out_4 = theta_out_3;
        theta_out_3 = theta_out_2;
        theta_out_2 = theta_out_1;
        theta_out_1 = theta_out_0;
        theta_out_0 = ( (int) theta_0_d ); // + theta_base;
        
        encoder_speed = (SPEED_SCALE*SUB_SAMPLE_FREQUENCE)*(
            theta_out_0 - theta_out_1
        );
        low_2_speed = (SPEED_SCALE*SUB_SAMPLE_FREQUENCE/2)*(
            theta_out_0 - theta_out_2
        );
        low_3_speed = (SPEED_SCALE*SUB_SAMPLE_FREQUENCE/3)*(
            theta_out_0 - theta_out_3
        );
        low_4_speed = (SPEED_SCALE*SUB_SAMPLE_FREQUENCE/4)*(
            theta_out_0 - theta_out_4
        );
        low_8_speed = (SPEED_SCALE*SUB_SAMPLE_FREQUENCE/8)*(
            theta_out_0 - theta_out_8
        );
        servo_set_flag();
        encoder_counter = 0;
    }
    if (encoder_read_state == -1) {
        encoder_read_state = 0;
        GPIOB->regs->BSRR = (1U << 12) << 16;
        SPI2->regs->DR = 0x7f;
        spi_irq_enable(SPI2, SPI_TXE_INTERRUPT);
    }

    return 0;
}

TERMINAL_COMMAND(erv, "Encoder Read Value")
{
    while (!SerialUSB.available()) {
        encoder_read_value();
        while (encoder_read_state != -1) {
            watchdog_feed();
        }

        SerialUSB.print(encoder_read_result);
        SerialUSB.print(" (");
        SerialUSB.print(encoder_magnitude);
        SerialUSB.print(")");
        SerialUSB.println();

        delay(5);
        watchdog_feed();
    }
}

void encoder_irq()
{
    encoder_read_value();
}

static void init_timer()
{
    HardwareTimer timer(4);

    // Configuring timer
    timer.pause();
    timer.setPrescaleFactor(9);
    timer.setOverflow(1000); // 8Khz

    timer.setChannel4Mode(TIMER_OUTPUT_COMPARE);
    timer.setCompare(TIMER_CH4, 1);
    timer.attachCompare4Interrupt(encoder_irq);

    timer.refresh();
    timer.resume();
}

void encoder_init()
{
    // Initializing pins
    digitalWrite(ENCODER_SELECT_PIN, HIGH);
    encoder.begin(SPI_9MHZ, MSBFIRST, SPI_MODE_LOW_FALLING);
    pinMode(ENCODER_SELECT_PIN, OUTPUT);

    encoder_read_value();

    init_timer();
}



void encoder_tick()
{
}

uint32_t encoder_value()
{
    return encoder_cnt;
}

TERMINAL_COMMAND(eb, "Encoder benchmark")
{
    int start = micros();
    for (int k=0; k<10000; k++) {
        watchdog_feed();
        encoder_read_value();
    }
    terminal_io()->println((micros()-start)/10000.0);
}

TERMINAL_COMMAND(cnt, "Cnt debug")
{
    terminal_io()->println(encoder_cnt);
}

TERMINAL_COMMAND(spd, "Speed debug")
{
    float result = ( (float) encoder_speed) / SPEED_NOMRALISATION;

    terminal_io()->print("theta_0 : ");
    terminal_io()->println( ((float)theta_out_0)/0x4000);

    terminal_io()->print("encoder_cnt : ");
    terminal_io()->println(encoder_cnt);
    terminal_io()->print("speed cnt : ");
    terminal_io()->println(encoder_speed);
    terminal_io()->print("speed : ");
    terminal_io()->println(result);
    terminal_io()->print("low 2 speed : ");
    terminal_io()->println( ( (float) low_2_speed) / SPEED_NOMRALISATION );
    terminal_io()->print("low 3 speed : ");
    terminal_io()->println( ( (float) low_3_speed) / SPEED_NOMRALISATION );
    terminal_io()->print("low 4 speed : ");
    terminal_io()->println( ( (float) low_4_speed) / SPEED_NOMRALISATION );
    terminal_io()->print("low 8 speed : ");
    terminal_io()->println( ( (float) low_8_speed) / SPEED_NOMRALISATION );
}

float encoder_to_turn(){
    if( encoder_cnt >= HALF_MAX_ENCODER_CNT ){
        return (encoder_cnt - MAX_ENCODER_CNT)/16384.0;
    }else{
        return encoder_cnt/16384.0; 
    }
}

int encoder_to_speed(){
    return encoder_speed;
}

int encoder_position(){
    return theta_out_0;
}

#endif
