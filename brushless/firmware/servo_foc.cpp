#include <stdlib.h>
#include <wirish/wirish.h>
#include <terminal.h>
#include "hardware.h"
#include "motor_foc.h"
#include "servo_foc.h"
#include "encoder.h"
#include "security.h"
#include "ssl.h"

void servo_foc_init()
{
}

TERMINAL_PARAMETER_BOOL(manual_speed, "Enable manual Speed consign", MANUAL_SPEED);

static bool servo_ticking = false;

// begin of automatic code - generated by integer_calculus.py
static int speed_csg = 0*134217728;
// end of automatic code - generated by integer_calculus.py

// begin of automatic code - generated by integer_calculus.py
static int theta_c = 0;
static int k_pos_p = K_POS_P*1073741824;
static int speed_i = 0;
static int k_pos_i = K_POS_I*67108864;
static int k_speed_p = K_SPEED_P*4194304;
static int voltage_i = 0;
static int k_speed_i = K_SPEED_I*524288;
static int k_fem = KFEM*16777216;
// end of automatic code - generated by integer_calculus.py


static int output_voltage_d = 0;
// begin of automatic code - generated by integer_calculus.py
static int output_voltage_q = 0;
static int reference_voltage_q = 0;
static int voltage_q = 0;
static int voltage_p = 0;
static int limited_speed_error = 0;
static int speed_error = 0;
static int speed_c = 0;
static int speed_p = 0;
static int limited_theta_error = 0;
static int theta_error = 0;
static int speed_i__acc_sum = 0;
static int speed_load = 0;
static int voltage_i__acc_sum = 0;
static int voltage_load = 0;
static int electromagnetic_force = 0;
// end of automatic code - generated by integer_calculus.py

static int max_output_voltage = 0;
static int speed=0;
static int theta=0;

void control_with_vectorial_command(){

    if( servo_ticking ){
        return;
    }
    servo_ticking = true;

    if( ! get_serv_flag() ){
        servo_ticking = false;
        return;
    }

    if( motor_is_tared() ){
        theta = rotor_angle();
        _Static_assert( SPEED_NOMRALISATION==1048576, "");
        speed = encoder_to_speed();

        #ifdef STOP_OUTSIDE_LIMITS 
        if( theta < min_theta or theta > max_theta ){
            motor_foc_set( false, 0 );
        }
        #endif

        // Compute velocity consign 
        if(!manual_speed){
            // begin of automatic code - generated by integer_calculus.py
            theta_error = ((-theta)*8 + theta_c/2);
            limited_theta_error = ( (theta_error > 655360) ? 655360 : ( (theta_error < -655360) ? -655360 : theta_error ) );
            speed_p = ((limited_theta_error/16)*(k_pos_p/65536));
            speed_load = ((((limited_theta_error/16)*(k_pos_i/32768))/32768)*((2684354)/64));
            speed_i__acc_sum = (speed_i/1 + speed_load/128);
            speed_i = (( (speed_i__acc_sum > 1207959552) ? 1207959552 : ( (speed_i__acc_sum < -1207959552) ? -1207959552 : speed_i__acc_sum ) )*1);
            speed_c = ( ((speed_p/2 + speed_i/2) > 603979776) ? 603979776 : ( ((speed_p/2 + speed_i/2) < -603979776) ? -603979776 : (speed_p/2 + speed_i/2) ) );
            // end of automatic code - generated by integer_calculus.py
        }else{
            // begin of automatic code - generated by integer_calculus.py
            speed_c = (speed_csg/2);
            // end of automatic code - generated by integer_calculus.py
        }

        // begin of automatic code - generated by integer_calculus.py
        speed_error = ((-speed)*8 + speed_c/8);
        limited_speed_error = ( (speed_error > 33554432) ? 33554432 : ( (speed_error < -33554432) ? -33554432 : speed_error ) );
        voltage_p = ((limited_speed_error/1024)*(k_speed_p/32768));
        voltage_load = ((((limited_speed_error/1024)*(k_speed_i/32768))/32768)*((2684354)/64));
        voltage_i__acc_sum = (voltage_i/1 + voltage_load/128);
        voltage_i = (( (voltage_i__acc_sum > 1073741824) ? 1073741824 : ( (voltage_i__acc_sum < -1073741824) ? -1073741824 : voltage_i__acc_sum ) )*1);
        electromagnetic_force = ((speed/4096)*(k_fem/32768));
        voltage_q = ((electromagnetic_force/1 + voltage_i/8)/2 + voltage_p/16);
        reference_voltage_q = ( (voltage_q > 67108864) ? 67108864 : ( (voltage_q < -67108864) ? -67108864 : voltage_q ) );
        output_voltage_q = (reference_voltage_q/65536);
        // end of automatic code - generated by integer_calculus.py

        if( max_output_voltage<output_voltage_q){
            max_output_voltage = output_voltage_q;
        }
        output_voltage_d = 0;
        direct_quadrature_voltage_set(output_voltage_d, output_voltage_q);
    }
    
    reset_serv_flag();
    servo_ticking = false;
}

void servo_foc_tick()
{
    if (security_get_error() != SECURITY_NO_ERROR) {
        motor_foc_set(false, 0);
    } else {
        control_with_vectorial_command();
    }
}

void servo_foc_set(bool enable, float target, int16_t pwm)
{
    if (!enable) {
        motor_foc_set(false, 0);
        security_set_error(SECURITY_NO_ERROR);
    }
}

void servo_foc_emergency(){
    servo_foc_set(false, 0);
}
void servo_foc_stop(){
    servo_foc_set(false, 0);
    motor_foc_set(true, 0);
}

TERMINAL_COMMAND(kpp, "Set P for position PID")
{
    if (argc == 1) {
        // begin of automatic code - generated by integer_calculus.py
        float k_pos_p_input = atof(argv[0]);
        if(k_pos_p_input < 0.0) k_pos_p_input = 0.0;
        if(k_pos_p_input > 1.8) k_pos_p_input = 1.8;
        k_pos_p = (int) (k_pos_p_input * 1073741824);
        // end of automatic code - generated by integer_calculus.py
    } else {
        if(argc==0){
            terminal_io()->println(((double)k_pos_p)/1073741824);
            return;
        }
        terminal_io()->println("Usage: kpp [0.0 - 1.8]");
    }
}
TERMINAL_COMMAND(kpi, "Set I for position PID")
{
    if (argc == 1) {
        // begin of automatic code - generated by integer_calculus.py
        float k_pos_i_input = atof(argv[0]);
        if(k_pos_i_input < 0.0) k_pos_i_input = 0.0;
        if(k_pos_i_input > 18.0) k_pos_i_input = 18.0;
        k_pos_i = (int) (k_pos_i_input * 67108864);
        // end of automatic code - generated by integer_calculus.py
    } else {
        if(argc==0){
            terminal_io()->println(((double)k_pos_i)/67108864);
            return;
        }
        terminal_io()->println("Usage: kpi [0.0 - 18.0]");
    }
}
TERMINAL_COMMAND(ksp, "Set P for speed PID")
{
    if (argc == 1) {
        // begin of automatic code - generated by integer_calculus.py
        float k_speed_p_input = atof(argv[0]);
        if(k_speed_p_input < 0.0) k_speed_p_input = 0.0;
        if(k_speed_p_input > 256.0) k_speed_p_input = 256.0;
        k_speed_p = (int) (k_speed_p_input * 4194304);
        // end of automatic code - generated by integer_calculus.py
    } else {
        if(argc==0){
            terminal_io()->println(((double)k_speed_p)/4194304);
            return;
        }
        terminal_io()->println("Usage: ksp [ 0.0 - 256.0 ]");
    }
}
TERMINAL_COMMAND(ksi, "Set I for speed PID")
{
    if (argc == 1) {
        // begin of automatic code - generated by integer_calculus.py
        float k_speed_i_input = atof(argv[0]);
        if(k_speed_i_input < 0.0) k_speed_i_input = 0.0;
        if(k_speed_i_input > 2560.0) k_speed_i_input = 2560.0;
        k_speed_i = (int) (k_speed_i_input * 524288);
        // end of automatic code - generated by integer_calculus.py
    } else {
        if(argc==0){
            terminal_io()->println(((double)k_speed_i)/524288);
            return;
        }
        terminal_io()->println("Usage: ksi [ 0.0 - 2560.0 ]");
    }
}
TERMINAL_COMMAND(kem, "Set I for speed PID")
{
    if (argc == 1) {
        // begin of automatic code - generated by integer_calculus.py
        float k_fem_input = atof(argv[0]);
        if(k_fem_input < 0.0) k_fem_input = 0.0;
        if(k_fem_input > 113.777) k_fem_input = 113.777;
        k_fem = (int) (k_fem_input * 16777216);
        // end of automatic code - generated by integer_calculus.py
    } else {
        if(argc==0){
            terminal_io()->println(((double)k_fem)/16777216);
            return;
        }
        terminal_io()->println("Usage: kem [ 0.0 - 113.777 ]");
    }
}

TERMINAL_COMMAND(theta_c, "Set angle consign")
{
    if (argc == 1) {
        // begin of automatic code - generated by integer_calculus.py
        float theta_c_input = atof(argv[0]);
        if(theta_c_input < -6000.0) theta_c_input = -6000.0;
        if(theta_c_input > 6000.0) theta_c_input = 6000.0;
        theta_c = (int) (theta_c_input * 262144);
        // end of automatic code - generated by integer_calculus.py
    } else {
        if(argc==0){
            terminal_io()->println(((double)theta_c)/262144);
            return;
        }
        terminal_io()->println("Usage: theta_c [ -6000.0 - 6000.0 ]");
    }
}

TERMINAL_COMMAND(info, "Info")
{
//    terminal_io()->print("theta : ");
//    terminal_io()->println(theta);
//    terminal_io()->print("speed : ");
//    terminal_io()->println(speed);
    terminal_io()->println(speed_c);
//    terminal_io()->println(speed_error);
//    terminal_io()->print("em : ");
//    terminal_io()->println(electromagnetic_force);
//    terminal_io()->print("out_q : ");
//    terminal_io()->println(output_voltage_q);
//    terminal_io()->print("max_out_q : ");
//    terminal_io()->println(max_output_voltage);
//    terminal_io()->print("speed_error : ");
//    terminal_io()->println(speed_error);
//    terminal_io()->print("limited_speed_error : ");
//    terminal_io()->println(limited_speed_error);
//    terminal_io()->print("voltage_p : ");
//    terminal_io()->println(voltage_p);
//      terminal_io()->println(voltage_load);
//      terminal_io()->println(voltage_i__acc_sum);
//      terminal_io()->println(voltage_i);
//terminal_io()->println(theta_error);
//terminal_io()->println(limited_theta_error);
//terminal_io()->println(speed_p);
//terminal_io()->println(speed_load);
//terminal_io()->println(speed_i__acc_sum);
//terminal_io()->println(speed_i);
//terminal_io()->println(speed_c);

}

TERMINAL_COMMAND(speed_csg, "Set speed consign")
{
    if (argc == 1) {
        // begin of automatic code - generated by integer_calculus.py
        float speed_csg_input = atof(argv[0]);
        if(speed_csg_input < -9.0) speed_csg_input = -9.0;
        if(speed_csg_input > 9.0) speed_csg_input = 9.0;
        speed_csg = (int) (speed_csg_input * 134217728);
        // end of automatic code - generated by integer_calculus.py
    } else {
        if(argc==0){
            terminal_io()->println((double)speed_csg/134217728);
            return;
        }
        terminal_io()->println("Usage: speed_csg [ -9.0 - 9.0 ]");
    }
}

/**
 * Current speed [turn/s]
 */
float servo_foc_get_speed(){
    return speed/SPEED_NOMRALISATION;
}

/**
 * Current PWM output [-3000 to 3000]
 */
int servo_foc_get_pwm(){
    return 0; 
}

void servo_foc_set_pid(float kp, float ki, float kd){
}
